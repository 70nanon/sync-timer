# SyncTimer MVP 実装計画

## 1. コンセプト
「待ち」をポストするシンプルなSNS。
- タイマー = 1ポスト
- 同じ end_time を待つ人数が表示される
- 他人の待ちに「私も待つ」で参加できる
- チャットルーム型ではない

---

## 2. MVPゴール
以下の機能を実装する：
1. タイマー（ポスト）を作成できる
2. タイムラインに表示される
3. 各ポストに同時待機人数が表示される
4. 「私も待つ」ボタンで同じ end_time に参加できる
5. カウントダウン表示
6. 0秒到達時に同時人数を表示

※ ユーザー登録は行わない（匿名）

---

## 3. データ設計（Firebase Firestore）

### 3.1 timers コレクション
```typescript
{
  id: string,                    // 自動生成ID
  title: string,                 // "ラーメン完成まで"
  endTime: Timestamp,            // Firebase Timestamp型
  endTimeGroup: string,          // "2026-01-01T00:00:00Z" (秒単位、カウント用)
  nickname: string,              // "たろう"
  createdAt: Timestamp,          // 作成日時（サーバータイムスタンプ）
}
```

### 3.2 timer_counts コレクション（Phase 2で導入）
```typescript
{
  endTimeGroup: string,          // ドキュメントID: "2026-01-01T00:00:00Z"
  count: number,                 // 1242
  lastUpdated: Timestamp,        // 最終更新時刻
}
```

### 3.3 設計方針
- タイマー = ポスト
- イベントテーブルは作らない
- 同じ `endTimeGroup` を持つレコード群が「同じ待ち」
- `endTime` は必ず **秒単位に丸めて** UTC 保存
- `endTimeGroup` は ISO 文字列形式（秒単位）

### 3.4 Firestore インデックス
```javascript
// 複合インデックス（Firebase Console で設定）
timers:
  - endTime (ASC) + createdAt (DESC)
  - endTimeGroup (ASC) + createdAt (DESC)
```

---

## 4. API設計（Firestore操作）

### 4.1 タイマー作成
```typescript
const createTimer = async (data: {
  title: string;
  endTime: Date;
  nickname: string;
}) => {
  // 秒単位に丸める
  const roundedEndTime = new Date(data.endTime);
  roundedEndTime.setMilliseconds(0);
  const endTimeGroup = roundedEndTime.toISOString();
  
  await addDoc(collection(db, 'timers'), {
    title: data.title,
    endTime: Timestamp.fromDate(roundedEndTime),
    endTimeGroup: endTimeGroup,
    nickname: data.nickname,
    createdAt: serverTimestamp(),
  });
};
```

---

### 4.2 タイムライン取得
```typescript
const getTimeline = async (limit = 50) => {
  const q = query(
    collection(db, 'timers'),
    where('endTime', '>', Timestamp.now()),
    orderBy('endTime', 'asc'),
    orderBy('createdAt', 'desc'),
    limit(limit)
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
};
```

**特徴:**
- 未来のタイマーのみ取得
- endTime が近い順にソート
- リアルタイムリスナー（`onSnapshot`）も使用可能

---

### 4.3 同時待機人数取得

**Phase 1（シンプル）:**
```typescript
const getWaitCount = async (endTimeGroup: string) => {
  const q = query(
    collection(db, 'timers'),
    where('endTimeGroup', '==', endTimeGroup)
  );
  
  const snapshot = await getCountFromServer(q);
  return snapshot.data().count;
};
```

**Phase 2（推奨・最適化版）:**
```typescript
// timer_counts コレクションから取得
const getWaitCount = async (endTimeGroup: string) => {
  const countRef = doc(db, 'timer_counts', endTimeGroup);
  const snapshot = await getDoc(countRef);
  return snapshot.data()?.count || 0;
};

// リアルタイムリスナー版
const subscribeToWaitCount = (
  endTimeGroup: string,
  callback: (count: number) => void
) => {
  const countRef = doc(db, 'timer_counts', endTimeGroup);
  return onSnapshot(countRef, (doc) => {
    callback(doc.data()?.count || 0);
  });
};
```

---

### 4.4 「私も待つ」
```typescript
const joinWait = async (originalTimer: {
  title: string;
  endTime: Timestamp;
  endTimeGroup: string;
}, myNickname: string) => {
  // 新規タイマーを作成
  await addDoc(collection(db, 'timers'), {
    title: originalTimer.title,
    endTime: originalTimer.endTime,
    endTimeGroup: originalTimer.endTimeGroup,
    nickname: myNickname,
    createdAt: serverTimestamp(),
  });
  
  // Phase 2: カウントを更新
  const countRef = doc(db, 'timer_counts', originalTimer.endTimeGroup);
  await setDoc(countRef, {
    count: increment(1),
    lastUpdated: serverTimestamp()
  }, { merge: true });
};
```

内部的には新規 INSERT（`addDoc`）を行うだけ  
完全に同じ `endTimeGroup` を持つ新規レコードを作成する

---

## 5. フロントエンド仕様
## 5. フロントエンド仕様

### 5.1 タイムライン画面
各ポストに表示する要素：
- タイトル
- ニックネーム
- 残り時間（リアルタイム更新）
- 同時待機人数
- 「私も待つ」ボタン

---

### 5.2 カウントダウン仕様
- クライアント側で1秒ごとに更新
- `Date.now()` を基準に計算
- 0秒到達時に終了表示
- 0秒到達時に再度 count 取得

表示例：  
🎉 **今この瞬間、1,242人が同時にゼロを迎えました**

---

### 5.3 人数更新（リアルタイム）
Firebase Firestore のリアルタイムリスナー（`onSnapshot`）を使用  
**5秒ポーリングは不要！**

**Phase 1:**
- タイムライン全体をリアルタイムリスナーで購読
- 新しいタイマーが追加されたら自動で反映

**Phase 2:**
- `timer_counts` コレクションもリアルタイムリスナーで購読
- カウントが変更されたら即座に反映

---

## 6. UX設計思想
- 「私も待つ」で人数が増える体験が核
- 数字がコミュニケーションになる
- 同時ゼロの瞬間を共有する
- タイマーはポストとして流れる構造

---

## 7. 今回実装しないもの
- ユーザー登録 / ログイン
- コメント機能
- リアクション
- 削除 / 編集機能
- 通知機能（ブラウザ通知）
- イベントテーブル

---

## 8. 技術的な決定事項

### 8.1 バックエンド
- **Firebase Firestore**: NoSQLデータベース
- **Firebase Cloud Functions**: 集計処理（Phase 2）
- **Firebase Hosting**: 静的ホスティング

### 8.2 フロントエンド
- **React 18 + TypeScript**
- **Vite**: ビルドツール
- **date-fns**: 日時処理
- **Firebase SDK**: Firestore操作

### 8.3 データ取得戦略
- **タイムライン**: `onSnapshot` でリアルタイム購読
- **カウント（Phase 1）**: `getCountFromServer` で都度取得
- **カウント（Phase 2）**: `timer_counts` をリアルタイム購読

### 8.4 コスト最適化
- リアルタイムリスナー活用（初回のみ課金）
- 集計ドキュメントパターン（timer_counts）
- 古いタイマーの自動削除（24時間後）

---

## 9. 実装フェーズ

### Phase 1: MVP（Cloud Functions なし）
1. Firebase プロジェクト作成
2. Firestore セットアップ
3. タイマー作成機能
4. タイムライン表示
5. カウントダウン表示
6. 「私も待つ」機能
7. COUNT クエリでカウント取得

**特徴:**
- シンプルな実装
- Cloud Functions 不要
- やや読み取りコストが高い

### Phase 2: 最適化（推奨）
1. `timer_counts` コレクション導入
2. カウント集計の最適化
3. リアルタイムリスナーでカウント購読
4. 古いタイマーの自動削除

**特徴:**
- パフォーマンス向上
- コスト最適化
- よりスケーラブル

### Phase 3: スケール対応
1. Cloud Functions でカウント集計
2. Cloud Scheduler で定期クリーンアップ
3. Firebase Analytics 導入
4. エラーロギング（Sentry など）

---

## 10. Claude向け要約
タイマーをポストとして扱うシンプルなSNSを、**Firebase Firestore** で実装する。

**重要な変更点:**
- PostgreSQL → Firebase Firestore
- REST API → Firebase SDK（直接操作）
- 5秒ポーリング → リアルタイムリスナー
- `end_time` 完全一致 → `endTimeGroup`（秒単位ISO文字列）
- COUNT クエリ → `timer_counts` コレクション（Phase 2）

同じ `endTimeGroup` を持つレコードの件数を「同時待機人数」として表示し、「私も待つ」ボタンで同じ `endTimeGroup` の新規タイマーを作成できるようにする。ユーザー認証やイベントテーブルは不要。